# 持仓调整逻辑技术需求文档

## 1. 功能概述

持仓调整逻辑是一个复杂的Delta管理系统，用于自动调整持仓以达到目标Delta，支持基于TradingView信号的持仓再平衡。

## 2. 核心特性

### 2.1 Delta计算和管理
- 实时Delta计算
- 目标Delta设定
- Delta偏差监控
- 自动再平衡触发

### 2.2 持仓调整策略
- 基于Delta的持仓调整
- 支持多种调整方式（开仓、平仓、调仓）
- 最小交易量控制
- 成本优化

### 2.3 信号集成
- TradingView信号ID集成
- 信号验证和处理
- 多信号冲突处理
- 信号优先级管理

## 3. 技术架构

### 3.1 类结构设计

```python
class PositionAdjustmentService:
    """持仓调整服务主类"""

    def __init__(self, deribit_client, delta_manager, config):
        self.client = deribit_client
        self.delta_manager = delta_manager
        self.config = config
        self.signal_history = {}

    async def adjust_position_to_target_delta(self, target_delta, signal_id=None):
        """调整持仓到目标Delta"""
        pass

    async def calculate_position_adjustment(self, current_delta, target_delta):
        """计算持仓调整方案"""
        pass

    async def execute_adjustment_orders(self, adjustment_plan):
        """执行调整订单"""
        pass

    async def process_tradingview_signal(self, signal_data):
        """处理TradingView信号"""
        pass
```

### 3.2 Delta管理器

```python
class DeltaManager:
    """Delta管理器"""

    def __init__(self, position_db, config):
        self.position_db = position_db
        self.config = config

    async def get_current_delta(self):
        """获取当前总Delta"""
        pass

    async def get_target_delta(self, signal_id=None):
        """获取目标Delta"""
        pass

    async def calculate_delta_deviation(self, current_delta, target_delta):
        """计算Delta偏差"""
        pass

    async def record_delta_change(self, old_delta, new_delta, reason):
        """记录Delta变更"""
        pass
```

### 3.3 配置参数

```python
POSITION_ADJUSTMENT_CONFIG = {
    "enabled": True,
    "delta_threshold": 0.1,  # Delta偏差阈值
    "min_adjustment_amount": 0.1,  # 最小调整数量
    "max_adjustment_amount": 10.0,  # 最大调整数量
    "adjustment_cost_threshold": 0.01,  # 调整成本阈值
    "signal_expiry_time": 300000,  # 信号过期时间(毫秒)
    "adjustment_strategies": {
        "aggressive": {
            "delta_threshold": 0.05,
            "priority": "speed"
        },
        "conservative": {
            "delta_threshold": 0.15,
            "priority": "cost"
        },
        "balanced": {
            "delta_threshold": 0.1,
            "priority": "balanced"
        }
    }
}
```

## 4. API接口设计

### 4.1 持仓调整接口

```python
async def adjust_position_to_target(
    target_delta: float,
    strategy: str = "balanced",
    signal_id: str = None,
    max_cost: float = None,
    timeout: int = 30000
) -> Dict:
    """
    调整持仓到目标Delta

    Args:
        target_delta: 目标Delta值
        strategy: 调整策略
        signal_id: 信号ID
        max_cost: 最大调整成本
        timeout: 超时时间(毫秒)

    Returns:
        Dict: 调整结果
    """
```

### 4.2 Delta查询接口

```python
async def get_position_delta(
    include_pending_orders: bool = True,
    precision: int = 4
) -> Dict:
    """
    获取当前持仓Delta

    Args:
        include_pending_orders: 是否包含待处理订单
        precision: 精度

    Returns:
        Dict: Delta信息
    """
```

### 4.3 信号处理接口

```python
async def process_tradingview_signal(
    signal_id: str,
    signal_data: Dict,
    priority: str = "normal"
) -> Dict:
    """
    处理TradingView信号

    Args:
        signal_id: 信号ID
        signal_data: 信号数据
        priority: 信号优先级

    Returns:
        Dict: 处理结果
    """
```

## 5. 业务逻辑流程

### 5.1 Delta计算流程

1. **数据收集**
   - 获取所有持仓信息
   - 获取待处理订单信息
   - 获取市场价格数据

2. **Delta计算**
   - 计算每个持仓的Delta
   - 计算待处理订单的Delta影响
   - 计算总Delta

3. **目标设定**
   - 基于信号设定目标Delta
   - 验证目标Delta的合理性
   - 考虑风险限制

4. **偏差分析**
   - 计算当前与目标的偏差
   - 判断是否需要调整
   - 评估调整成本

### 5.2 调整策略算法

```python
def calculate_adjustment_plan(self, current_delta, target_delta, strategy):
    """
    计算调整方案

    Args:
        current_delta: 当前Delta
        target_delta: 目标Delta
        strategy: 调整策略

    Returns:
        Dict: 调整方案
    """
    delta_diff = target_delta - current_delta

    if abs(delta_diff) < self.config["delta_threshold"]:
        return {"action": "none", "reason": "delta_threshold_not_met"}

    # 根据策略选择调整方式
    if strategy == "aggressive":
        return self._aggressive_adjustment(delta_diff)
    elif strategy == "conservative":
        return self._conservative_adjustment(delta_diff)
    else:
        return self._balanced_adjustment(delta_diff)
```

### 5.3 信号处理流程

1. **信号验证**
   - 验证信号格式
   - 检查信号时效性
   - 验证信号权限

2. **信号解析**
   - 解析目标Delta
   - 解析调整参数
   - 解析优先级

3. **冲突处理**
   - 检查信号冲突
   - 应用优先级规则
   - 决定执行策略

4. **执行监控**
   - 执行调整操作
   - 监控执行结果
   - 记录执行日志

## 6. 数据库设计

### 6.1 Delta记录表

```python
class DeltaRecord(BaseModel):
    """Delta记录"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    old_delta: float
    new_delta: float
    delta_change: float
    reason: str
    signal_id: str = None
    adjustment_cost: float = 0.0
    status: str = "completed"  # completed, failed, pending
```

### 6.2 信号记录表

```python
class SignalRecord(BaseModel):
    """信号记录"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    signal_id: str
    timestamp: datetime
    signal_data: Dict
    processed: bool = False
    processed_at: datetime = None
    result: Dict = None
    priority: str = "normal"
```

### 6.3 持仓调整历史表

```python
class AdjustmentHistory(BaseModel):
    """持仓调整历史"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime
    target_delta: float
    current_delta: float
    adjustment_plan: Dict
    execution_result: Dict
    total_cost: float
    execution_time: float
    strategy: str
```

## 7. 错误处理

### 7.1 异常类型

```python
class PositionAdjustmentError(Exception):
    """持仓调整基础异常"""
    pass

class DeltaCalculationError(PositionAdjustmentError):
    """Delta计算异常"""
    pass

class AdjustmentExecutionError(PositionAdjustmentError):
    """调整执行异常"""
    pass

class SignalValidationError(PositionAdjustmentError):
    """信号验证异常"""
    pass

class InsufficientBalanceError(PositionAdjustmentError):
    """余额不足异常"""
    pass
```

### 7.2 错误恢复策略

- Delta计算错误：使用缓存值或手动输入
- 调整执行失败：记录失败原因并重试
- 信号冲突：根据优先级处理
- 网络问题：自动重试机制

## 8. 监控和日志

### 8.1 关键指标

- Delta偏差率
- 调整执行时间
- 调整成本
- 信号处理成功率

### 8.2 日志记录

```python
import logging

logger = logging.getLogger(__name__)

def log_delta_change(old_delta, new_delta, reason, cost=0.0):
    """记录Delta变更日志"""
    logger.info(f"Delta changed from {old_delta} to {new_delta}")
    logger.info(f"Reason: {reason}, Cost: {cost}")

def log_adjustment_execution(adjustment_plan, result, execution_time):
    """记录调整执行日志"""
    logger.info(f"Adjustment executed in {execution_time}ms")
    logger.info(f"Plan: {adjustment_plan}")
    logger.info(f"Result: {result}")
```

## 9. 风险控制

### 9.1 风险限制

```python
RISK_CONTROLS = {
    "max_daily_adjustments": 10,  # 每日最大调整次数
    "max_delta_change_per_trade": 5.0,  # 单次交易最大Delta变化
    "max_total_cost_per_day": 1000.0,  # 每日最大调整成本
    "min_time_between_adjustments": 300,  # 调整间隔最小时间(秒)
    "max_position_concentration": 0.3,  # 单个持仓最大集中度
}
```

### 9.2 风险检查

```python
async def check_risk_limits(self, adjustment_plan):
    """
    检查风险限制

    Args:
        adjustment_plan: 调整方案

    Returns:
        bool: 是否通过风险检查
    """
    # 检查每日调整次数
    if await self._get_daily_adjustment_count() >= RISK_CONTROLS["max_daily_adjustments"]:
        raise RiskLimitExceededError("Daily adjustment limit exceeded")

    # 检查Delta变化
    if abs(adjustment_plan["delta_change"]) > RISK_CONTROLS["max_delta_change_per_trade"]:
        raise RiskLimitExceededError("Delta change limit exceeded")

    # 检查成本
    if adjustment_plan["estimated_cost"] > RISK_CONTROLS["max_total_cost_per_day"]:
        raise RiskLimitExceededError("Cost limit exceeded")

    return True
```

## 10. 性能优化

### 10.1 缓存策略

- Delta计算结果缓存
- 持仓信息缓存
- 市场数据缓存
- 调整历史缓存

### 10.2 异步处理

- 异步Delta计算
- 异步订单执行
- 异步信号处理
- 异步日志记录

### 10.3 负载控制

- 并发调整控制
- 队列管理
- 资源使用限制
- 优先级调度

## 11. 测试策略

### 11.1 单元测试

- Delta计算测试
- 调整策略测试
- 信号处理测试
- 风险控制测试

### 11.2 集成测试

- 与Deribit API集成测试
- 数据库集成测试
- 信号系统集成测试
- 监控系统集成测试

### 11.3 压力测试

- 高频信号处理测试
- 大规模持仓调整测试
- 并发处理测试
- 故障恢复测试

## 12. 实施优先级

1. **Phase 1**: 基础Delta管理和调整逻辑
2. **Phase 2**: 信号集成和冲突处理
3. **Phase 3**: 风险控制和性能优化
4. **Phase 4**: 监控告警和高级特性

## 13. 依赖关系

- Deribit Python客户端
- 数据库访问层
- 配置管理模块
- 日志系统
- 监控系统
- 信号接收服务

## 14. 扩展性考虑

### 14.1 多策略支持

- 支持自定义调整策略
- 策略热切换
- A/B测试框架

### 14.2 多市场支持

- 支持多个交易所
- 支持多种资产类型
- 支持跨市场套利

### 14.3 机器学习集成

- 基于历史数据优化调整策略
- 预测性Delta管理
- 自适应风险控制