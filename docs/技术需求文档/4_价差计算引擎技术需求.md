# 价差计算引擎技术需求文档

## 1. 功能概述

价差计算引擎是一个复杂的买卖价差分析系统，提供实时的价差监控、流动性评估和价差比例计算，为智能定价和订单执行提供关键市场数据支持。

## 2. 核心特性

### 2.1 实时价差监控
- 实时买卖价差计算
- 多深度价差分析
- 价差变化趋势追踪
- 异常价差检测

### 2.2 流动性评估
- 订单簿深度分析
- 流动性评分计算
- 市场冲击成本估算
- 大额交易流动性评估

### 2.3 价差比例计算
- 相对价差比例计算
- 绝对价差计算
- 价差百分比分析
- 历史价差对比

### 2.4 刻度倍数计算
- 价格刻度识别
- 最优价格刻度计算
- 刻度倍数优化
- 交易所规则适配

## 3. 技术架构

### 3.1 类结构设计

```python
class SpreadCalculationEngine:
    """价差计算引擎主类"""

    def __init__(self, deribit_client, market_data_service, config):
        self.client = deribit_client
        self.market_data = market_data_service
        self.config = config
        self.spread_cache = {}
        self.historical_data = {}
        self.liquidity_cache = {}

    async def calculate_spread(self, instrument_name, depth=10):
        """计算价差"""
        pass

    async def analyze_liquidity(self, instrument_name, amount=None):
        """分析流动性"""
        pass

    async def calculate_spread_ratio(self, instrument_name):
        """计算价差比例"""
        pass

    async def get_optimal_tick_size(self, instrument_name, price):
        """获取最优价格刻度"""
        pass

    async def detect_spread_anomalies(self, instrument_name):
        """检测价差异常"""
        pass
```

### 3.2 流动性分析器

```python
class LiquidityAnalyzer:
    """流动性分析器"""

    def __init__(self, config):
        self.config = config
        self.liquidity_history = {}

    async def analyze_order_book_liquidity(self, order_book, amount=None):
        """分析订单簿流动性"""
        pass

    def calculate_liquidity_score(self, order_book):
        """计算流动性评分"""
        pass

    def estimate_market_impact(self, order_book, amount):
        """估算市场冲击"""
        pass

    def analyze_depth_profile(self, order_book):
        """分析深度特征"""
        pass
```

### 3.3 价差历史管理器

```python
class SpreadHistoryManager:
    """价差历史管理器"""

    def __init__(self, database, config):
        self.db = database
        self.config = config

    async def record_spread_data(self, instrument_name, spread_data):
        """记录价差数据"""
        pass

    async def get_historical_spread(self, instrument_name, period="1h"):
        """获取历史价差"""
        pass

    async def calculate_spread_statistics(self, instrument_name, period="24h"):
        """计算价差统计"""
        pass

    async def detect_spread_patterns(self, instrument_name):
        """检测价差模式"""
        pass
```

### 3.4 配置参数

```python
SPREAD_CALCULATION_CONFIG = {
    "enabled": True,
    "calculation_intervals": {
        "fast": 1000,    # 1秒快速计算
        "normal": 5000,  # 5秒正常计算
        "slow": 30000    # 30秒慢速计算
    },
    "spread_thresholds": {
        "tight": 0.001,      # 紧密价差
        "normal": 0.005,     # 正常价差
        "wide": 0.01,        # 宽价差
        "very_wide": 0.02,   # 极宽价差
        "abnormal": 0.05     # 异常价差
    },
    "liquidity_thresholds": {
        "high": 0.8,     # 高流动性
        "medium": 0.5,   # 中等流动性
        "low": 0.2,      # 低流动性
        "illiquid": 0.1  # 无流动性
    },
    "tick_sizes": {
        "futures": {
            "BTC": 0.5,
            "ETH": 0.05,
            "SOL": 0.001
        },
        "options": {
            "BTC": 0.0001,
            "ETH": 0.0001,
            "SOL": 0.00001
        },
        "spot": {
            "BTC": 0.1,
            "ETH": 0.01,
            "SOL": 0.001
        }
    },
    "depth_analysis": {
        "levels": [1, 5, 10, 20, 50],
        "weight_decay": 0.8,
        "impact_threshold": 0.01
    }
}
```

## 4. API接口设计

### 4.1 价差计算接口

```python
async def calculate_instrument_spread(
    instrument_name: str,
    depth: int = 10,
    include_history: bool = False,
    include_analysis: bool = True
) -> Dict:
    """
    计算标的价差

    Args:
        instrument_name: 标的名称
        depth: 深度层数
        include_history: 是否包含历史数据
        include_analysis: 是否包含分析结果

    Returns:
        Dict: 价差计算结果
    """
```

### 4.2 流动性分析接口

```python
async def analyze_liquidity(
    instrument_name: str,
    amount: float = None,
    depth: int = 20,
    include_impact: bool = True
) -> Dict:
    """
    分析流动性

    Args:
        instrument_name: 标的名称
        amount: 分析金额(可选)
        depth: 深度层数
        include_impact: 是否包含冲击成本

    Returns:
        Dict: 流动性分析结果
    """
```

### 4.3 价差比例计算接口

```python
async def calculate_spread_ratio(
    instrument_name: str,
    base_price: str = "mark",  # "mark", "index", "last"
    include_comparative: bool = True
) -> Dict:
    """
    计算价差比例

    Args:
        instrument_name: 标的名称
        base_price: 基准价格类型
        include_comparative: 是否包含对比数据

    Returns:
        Dict: 价差比例计算结果
    """
```

### 4.4 刻度计算接口

```python
async def calculate_optimal_tick_size(
    instrument_name: str,
    current_price: float,
    strategy: str = "standard"  # "standard", "aggressive", "conservative"
) -> Dict:
    """
    计算最优价格刻度

    Args:
        instrument_name: 标的名称
        current_price: 当前价格
        strategy: 计算策略

    Returns:
        Dict: 刻度计算结果
    """
```

## 5. 业务逻辑流程

### 5.1 价差计算流程

1. **数据获取**
   - 获取订单簿数据
   - 获取市场基准价格
   - 获取历史价差数据
   - 验证数据完整性

2. **基础计算**
   - 计算最佳买卖价
   - 计算绝对价差
   - 计算相对价差比例
   - 计算多深度价差

3. **分析处理**
   - 分析价差变化趋势
   - 检测异常价差
   - 计算价差统计信息
   - 生成价差等级

4. **结果输出**
   - 整合计算结果
   - 添加分析建议
   - 缓存计算结果
   - 返回完整数据

### 5.2 流动性分析算法

```python
async def analyze_liquidity(self, order_book, amount=None):
    """
    分析流动性

    Args:
        order_book: 订单簿数据
        amount: 分析金额

    Returns:
        Dict: 流动性分析结果
    """
    # 分析订单簿深度
    depth_analysis = self._analyze_depth_profile(order_book)

    # 计算流动性评分
    liquidity_score = self._calculate_liquidity_score(order_book)

    # 估算市场冲击
    market_impact = self._estimate_market_impact(order_book, amount) if amount else None

    # 分析价差特征
    spread_analysis = self._analyze_spread_characteristics(order_book)

    # 生成流动性等级
    liquidity_grade = self._determine_liquidity_grade(liquidity_score)

    return {
        "liquidity_score": liquidity_score,
        "liquidity_grade": liquidity_grade,
        "depth_analysis": depth_analysis,
        "market_impact": market_impact,
        "spread_analysis": spread_analysis,
        "timestamp": datetime.utcnow()
    }
```

### 5.3 价差比例计算算法

```python
def calculate_spread_ratio(self, order_book, base_price):
    """
    计算价差比例

    Args:
        order_book: 订单簿数据
        base_price: 基准价格

    Returns:
        float: 价差比例
    """
    if not order_book['bids'] or not order_book['asks']:
        return 0.0

    best_bid = order_book['bids'][0]['price']
    best_ask = order_book['asks'][0]['price']

    if best_bid <= 0 or best_ask <= 0:
        return 0.0

    # 计算绝对价差
    absolute_spread = best_ask - best_bid

    # 计算相对价差比例
    relative_spread_ratio = absolute_spread / best_bid

    # 基于基准价格调整
    if base_price and base_price > 0:
        adjusted_ratio = absolute_spread / base_price
    else:
        adjusted_ratio = relative_spread_ratio

    return adjusted_ratio
```

### 5.4 刻度倍数计算算法

```python
def calculate_tick_multiplier(self, instrument_name, current_price):
    """
    计算刻度倍数

    Args:
        instrument_name: 标的名称
        current_price: 当前价格

    Returns:
        Dict: 刻度倍数计算结果
    """
    # 获取基础刻度大小
    base_tick = self._get_base_tick_size(instrument_name)

    # 根据价格动态调整
    if instrument_name.startswith(('BTC-', 'ETH-')):
        # 期权刻度计算
        multiplier = self._calculate_option_tick_multiplier(current_price)
    else:
        # 期货刻度计算
        multiplier = self._calculate_futures_tick_multiplier(current_price)

    # 计算最优刻度
    optimal_tick = base_tick * multiplier

    # 验证刻度有效性
    validated_tick = self._validate_tick_size(optimal_tick, instrument_name)

    return {
        "base_tick": base_tick,
        "multiplier": multiplier,
        "optimal_tick": optimal_tick,
        "validated_tick": validated_tick,
        "recommendation": self._get_tick_recommendation(validated_tick, current_price)
    }
```

## 6. 高级分析功能

### 6.1 价差异常检测

```python
async def detect_spread_anomalies(self, instrument_name, current_spread):
    """
    检测价差异常

    Args:
        instrument_name: 标的名称
        current_spread: 当前价差

    Returns:
        Dict: 异常检测结果
    """
    # 获取历史统计数据
    history = await self._get_historical_spread_stats(instrument_name)

    if not history:
        return {"anomaly_detected": False, "reason": "insufficient_history"}

    # 计算Z分数
    z_score = (current_spread - history['mean']) / history['std']

    # 检测异常
    anomaly_detected = abs(z_score) > 2.5  # 2.5标准差阈值

    # 分析异常类型
    if anomaly_detected:
        anomaly_type = "spike" if z_score > 0 else "drop"
        severity = "high" if abs(z_score) > 3 else "medium"
    else:
        anomaly_type = None
        severity = None

    return {
        "anomaly_detected": anomaly_detected,
        "anomaly_type": anomaly_type,
        "severity": severity,
        "z_score": z_score,
        "current_spread": current_spread,
        "historical_mean": history['mean'],
        "historical_std": history['std']
    }
```

### 6.2 深度加权分析

```python
def analyze_weighted_depth(self, order_book, weight_decay=0.8):
    """
    分析加权深度

    Args:
        order_book: 订单簿数据
        weight_decay: 权重衰减系数

    Returns:
        Dict: 加权深度分析结果
    """
    weighted_bid_depth = 0
    weighted_ask_depth = 0
    bid_levels = len(order_book['bids'])
    ask_levels = len(order_book['asks'])

    # 计算加权买方深度
    for i, level in enumerate(order_book['bids']):
        weight = weight_decay ** i
        weighted_bid_depth += level['amount'] * weight

    # 计算加权卖方深度
    for i, level in enumerate(order_book['asks']):
        weight = weight_decay ** i
        weighted_ask_depth += level['amount'] * weight

    # 计算深度平衡度
    total_weighted_depth = weighted_bid_depth + weighted_ask_depth
    depth_balance = abs(weighted_bid_depth - weighted_ask_depth) / total_weighted_depth if total_weighted_depth > 0 else 1

    return {
        "weighted_bid_depth": weighted_bid_depth,
        "weighted_ask_depth": weighted_ask_depth,
        "total_weighted_depth": total_weighted_depth,
        "depth_balance": depth_balance,
        "bid_levels": bid_levels,
        "ask_levels": ask_levels
    }
```

### 6.3 市场冲击估算

```python
def estimate_market_impact(self, order_book, amount, side='buy'):
    """
    估算市场冲击

    Args:
        order_book: 订单簿数据
        amount: 交易金额
        side: 交易方向

    Returns:
        Dict: 市场冲击估算结果
    """
    remaining_amount = amount
    weighted_avg_price = 0
    total_cost = 0
    levels_consumed = 0

    # 选择订单簿一侧
    book_side = order_book['asks'] if side == 'buy' else order_book['bids']

    for level in book_side:
        if remaining_amount <= 0:
            break

        level_amount = min(remaining_amount, level['amount'])
        level_cost = level_amount * level['price']

        weighted_avg_price = (weighted_avg_price * total_cost + level_price * level_cost) / (total_cost + level_cost) if total_cost > 0 else level['price']
        total_cost += level_cost
        remaining_amount -= level_amount
        levels_consumed += 1

    # 计算冲击成本
    best_price = book_side[0]['price'] if book_side else 0
    price_impact = (weighted_avg_price - best_price) / best_price if best_price > 0 else 0

    return {
        "estimated_avg_price": weighted_avg_price,
        "price_impact": price_impact,
        "total_cost": total_cost,
        "levels_consumed": levels_consumed,
        "remaining_liquidity": remaining_amount,
        "execution_probability": 1.0 if remaining_amount <= 0 else total_cost / (total_cost + remaining_amount * best_price)
    }
```

## 7. 数据缓存管理

### 7.1 多级缓存架构

```python
class SpreadCacheManager:
    """价差缓存管理器"""

    def __init__(self, config):
        self.config = config
        self.l1_cache = {}  # 内存缓存
        self.l2_cache_ttl = 60  # 二级缓存TTL
        self.l3_cache_ttl = 300  # 三级缓存TTL

    async def get_spread_data(self, instrument_name, cache_level=1):
        """获取价差数据"""
        # 尝试L1缓存
        if cache_level >= 1 and instrument_name in self.l1_cache:
            return self.l1_cache[instrument_name]

        # 尝试L2缓存
        if cache_level >= 2:
            l2_data = await self._get_l2_cache(instrument_name)
            if l2_data:
                self.l1_cache[instrument_name] = l2_data
                return l2_data

        # 尝试L3缓存
        if cache_level >= 3:
            l3_data = await self._get_l3_cache(instrument_name)
            if l3_data:
                self.l1_cache[instrument_name] = l3_data
                return l3_data

        return None

    async def set_spread_data(self, instrument_name, data):
        """设置价差数据"""
        # 更新L1缓存
        self.l1_cache[instrument_name] = data

        # 更新L2缓存
        await self._set_l2_cache(instrument_name, data)

        # 更新L3缓存
        await self._set_l3_cache(instrument_name, data)

    def cleanup_expired_cache(self):
        """清理过期缓存"""
        current_time = time.time()
        expired_keys = [
            key for key, data in self.l1_cache.items()
            if current_time - data.get('timestamp', 0) > 300  # 5分钟TTL
        ]
        for key in expired_keys:
            del self.l1_cache[key]
```

### 7.2 智能缓存策略

```python
def get_cache_strategy(self, instrument_name):
    """
    获取缓存策略

    Args:
        instrument_name: 标的名称

    Returns:
        Dict: 缓存策略
    """
    # 根据标的类型确定缓存策略
    if instrument_name.startswith(('BTC-PERPETUAL', 'ETH-PERPETUAL')):
        return {
            "cache_level": 1,
            "ttl": 5,
            "precision": "high"
        }
    elif instrument_name.startswith(('BTC-', 'ETH-')):
        return {
            "cache_level": 2,
            "ttl": 30,
            "precision": "medium"
        }
    else:
        return {
            "cache_level": 3,
            "ttl": 120,
            "precision": "low"
        }
```

## 8. 监控和指标

### 8.1 关键指标

- 价差计算准确率
- 流动性预测准确率
- 缓存命中率
- 响应时间
- 异常检测准确率

### 8.2 性能监控

```python
import time
from dataclasses import dataclass

@dataclass
class SpreadMetrics:
    """价差计算指标"""
    calculation_time: float
    cache_hit_rate: float
    accuracy_score: float
    anomaly_detection_rate: float
    timestamp: datetime

class SpreadMetricsCollector:
    """价差指标收集器"""

    def __init__(self):
        self.metrics_history = []
        self.current_metrics = None

    def record_calculation(self, start_time, end_time, cache_hit, accuracy):
        """记录计算指标"""
        calculation_time = end_time - start_time

        if not self.current_metrics:
            self.current_metrics = SpreadMetrics(
                calculation_time=calculation_time,
                cache_hit_rate=1.0 if cache_hit else 0.0,
                accuracy_score=accuracy,
                anomaly_detection_rate=0.0,
                timestamp=datetime.utcnow()
            )
        else:
            # 更新指标
            self.current_metrics.calculation_time = calculation_time
            if cache_hit:
                self.current_metrics.cache_hit_rate = 0.9 * self.current_metrics.cache_hit_rate + 0.1
            else:
                self.current_metrics.cache_hit_rate = 0.9 * self.current_metrics.cache_hit_rate
            self.current_metrics.accuracy_score = 0.9 * self.current_metrics.accuracy_score + 0.1 * accuracy

    def get_performance_summary(self):
        """获取性能摘要"""
        if not self.metrics_history:
            return {"status": "no_data"}

        recent_metrics = self.metrics_history[-100:]  # 最近100个数据点

        return {
            "avg_calculation_time": sum(m.calculation_time for m in recent_metrics) / len(recent_metrics),
            "avg_cache_hit_rate": sum(m.cache_hit_rate for m in recent_metrics) / len(recent_metrics),
            "avg_accuracy_score": sum(m.accuracy_score for m in recent_metrics) / len(recent_metrics),
            "total_calculations": len(self.metrics_history)
        }
```

## 9. 错误处理

### 9.1 异常类型

```python
class SpreadCalculationError(Exception):
    """价差计算基础异常"""
    pass

class InsufficientDataError(SpreadCalculationError):
    """数据不足异常"""
    pass

class InvalidOrderBookError(SpreadCalculationError):
    """无效订单簿异常"""
    pass

class CacheError(SpreadCalculationError):
    """缓存异常"""
    pass

class CalculationTimeoutError(SpreadCalculationError):
    """计算超时异常"""
    pass
```

### 9.2 错误恢复策略

- 订单簿数据异常：使用缓存数据或等待下次更新
- 计算超时：返回简化结果
- 缓存失败：直接计算
- 网络问题：使用历史数据

## 10. 测试策略

### 10.1 单元测试

- 价差计算算法测试
- 流动性分析测试
- 缓存机制测试
- 异常检测测试

### 10.2 集成测试

- 与Deribit API集成测试
- 市场数据服务集成测试
- 实时数据验证测试
- 压力场景测试

### 10.3 性能测试

- 大规模标的计算测试
- 高频数据更新测试
- 内存使用测试
- 响应时间测试

## 11. 实施优先级

1. **Phase 1**: 基础价差计算和流动性分析
2. **Phase 2**: 缓存机制和性能优化
3. **Phase 3**: 异常检测和高级分析
4. **Phase 4**: 监控系统和扩展功能

## 12. 依赖关系

- Deribit Python客户端
- 市场数据服务
- 缓存系统
- 数据库
- 监控系统
- 日志系统

## 13. 扩展性考虑

### 13.1 多交易所支持

- 支持不同交易所的价差计算
- 交易所特定规则适配
- 跨交易所价差套利

### 13.2 机器学习集成

- 基于历史数据的价差预测
- 异常检测模型优化
- 自适应性计算参数

### 13.3 实时分析

- WebSocket实时数据流
- 低延迟计算引擎
- 高频数据处理