# 智能订单定价技术需求文档

## 1. 功能概述

智能订单定价是一个高级的价格计算系统，提供分层定价、价差感知校正和期权专用精度处理，确保订单在最佳价格水平成交。

## 2. 核心特性

### 2.1 分层定价系统
- 基于交易量的分层定价
- 价格精度自动调整
- 多币种支持
- 实时价格验证

### 2.2 期权专用定价
- 期权价格精度处理
- Delta相关价格调整
- 到期日影响计算
- 隐含波动率考虑

### 2.3 价差感知校正
- 实时买卖价差监控
- 价差比例计算
- 流动性评估
- 价格滑点预测

### 2.4 市场适应性
- 实时市场数据集成
- 价格波动适应性
- 流动性变化响应
- 异常市场条件处理

## 3. 技术架构

### 3.1 类结构设计

```python
class SmartPriceCalculator:
    """智能价格计算器主类"""

    def __init__(self, deribit_client, market_data_service, config):
        self.client = deribit_client
        self.market_data = market_data_service
        self.config = config
        self.price_cache = {}
        self.spread_history = {}

    async def calculate_optimal_price(self, instrument_name, amount, direction, order_type="limit"):
        """计算最优价格"""
        pass

    async def apply_price_correction(self, base_price, instrument_name, market_conditions):
        """应用价格校正"""
        pass

    async def get_real_time_spread(self, instrument_name):
        """获取实时价差"""
        pass

    def calculate_tick_size(self, price, instrument_type):
        """计算价格刻度"""
        pass
```

### 3.2 期权定价器

```python
class OptionPriceCalculator:
    """期权专用定价器"""

    def __init__(self, config):
        self.config = config

    def calculate_option_price_adjustment(self, base_price, option_data):
        """计算期权价格调整"""
        pass

    def adjust_for_delta(self, price, delta, days_to_expiry):
        """基于Delta调整价格"""
        pass

    def calculate_precision_adjustment(self, price, instrument_name):
        """计算精度调整"""
        pass

    def apply_volatility_adjustment(self, price, implied_volatility):
        """应用波动率调整"""
        pass
```

### 3.3 价差分析器

```python
class SpreadAnalyzer:
    """价差分析器"""

    def __init__(self, config):
        self.config = config
        self.spread_cache = {}
        self.liquidity_scores = {}

    async def analyze_spread(self, instrument_name):
        """分析价差"""
        pass

    def calculate_spread_ratio(self, bid_price, ask_price):
        """计算价差比例"""
        pass

    def assess_liquidity(self, spread_ratio, volume):
        """评估流动性"""
        pass

    def predict_slippage(self, amount, spread_ratio):
        """预测价格滑点"""
        pass
```

### 3.4 配置参数

```python
SMART_PRICING_CONFIG = {
    "enabled": True,
    "price_levels": {
        "futures": {
            "small": {"threshold": 0.1, "adjustment": 0.0},
            "medium": {"threshold": 1.0, "adjustment": 0.001},
            "large": {"threshold": 10.0, "adjustment": 0.002},
            "xlarge": {"threshold": 100.0, "adjustment": 0.005}
        },
        "options": {
            "small": {"threshold": 1, "adjustment": 0.0},
            "medium": {"threshold": 10, "adjustment": 0.01},
            "large": {"threshold": 100, "adjustment": 0.02},
            "xlarge": {"threshold": 1000, "adjustment": 0.05}
        }
    },
    "spread_thresholds": {
        "tight": 0.001,  # 紧密价差阈值
        "normal": 0.005,  # 正常价差阈值
        "wide": 0.01,  # 宽价差阈值
        "very_wide": 0.02  # 极宽价差阈值
    },
    "option_pricing": {
        "delta_adjustment_factor": 0.1,
        "days_to_expiry_factor": 0.05,
        "implied_volatility_factor": 0.2,
        "minimum_premium": 0.01
    },
    "tick_sizes": {
        "futures": 0.01,
        "options": 0.0001,
        "spot": 0.01
    }
}
```

## 4. API接口设计

### 4.1 价格计算接口

```python
async def calculate_optimal_order_price(
    instrument_name: str,
    amount: float,
    direction: str,  # "buy" or "sell"
    order_type: str = "limit",
    strategy: str = "balanced",  # "aggressive", "balanced", "conservative"
    max_slippage: float = 0.005
) -> Dict:
    """
    计算最优订单价格

    Args:
        instrument_name: 交易标的名称
        amount: 订单数量
        direction: 交易方向
        order_type: 订单类型
        strategy: 定价策略
        max_slippage: 最大滑点

    Returns:
        Dict: 价格计算结果
    """
```

### 4.2 价格校正接口

```python
async def apply_smart_price_correction(
    base_price: float,
    instrument_name: str,
    market_conditions: Dict = None,
    correction_factors: Dict = None
) -> float:
    """
    应用智能价格校正

    Args:
        base_price: 基础价格
        instrument_name: 交易标的名称
        market_conditions: 市场条件
        correction_factors: 校正因子

    Returns:
        float: 校正后价格
    """
```

### 4.3 价差分析接口

```python
async def analyze_instrument_spread(
    instrument_name: str,
    depth: int = 10,
    include_history: bool = True
) -> Dict:
    """
    分析标的价差

    Args:
        instrument_name: 交易标的名称
        depth: 深度
        include_history: 是否包含历史数据

    Returns:
        Dict: 价差分析结果
    """
```

## 5. 业务逻辑流程

### 5.1 价格计算流程

1. **数据收集**
   - 获取当前市场数据
   - 获取历史价差数据
   - 获取订单簿信息
   - 获取标的信息

2. **基础定价**
   - 根据订单大小确定价格级别
   - 计算基础调整系数
   - 应用基本定价规则
   - 验证价格合理性

3. **市场适应**
   - 分析当前价差情况
   - 评估市场流动性
   - 预测价格滑点
   - 调整价格策略

4. **最终校正**
   - 应用特殊标的价格规则
   - 进行风险检查
   - 应用最终调整
   - 返回定价结果

### 5.2 期权定价算法

```python
def calculate_option_price(self, instrument_name, amount, direction, market_data):
    """
    计算期权价格

    Args:
        instrument_name: 期权名称
        amount: 数量
        direction: 方向
        market_data: 市场数据

    Returns:
        float: 期权价格
    """
    # 获取期权基本信息
    option_info = await self._get_option_info(instrument_name)

    # 计算基础价格
    base_price = market_data['mark_price']

    # 应用Delta调整
    delta_adjusted = self._apply_delta_adjustment(
        base_price,
        option_info['delta'],
        option_info['days_to_expiry']
    )

    # 应用精度调整
    precision_adjusted = self._apply_precision_adjustment(
        delta_adjusted,
        instrument_name
    )

    # 应用波动率调整
    volatility_adjusted = self._apply_volatility_adjustment(
        precision_adjusted,
        option_info['implied_volatility']
    )

    # 应用最小保证金限制
    final_price = max(volatility_adjusted, self.config['option_pricing']['minimum_premium'])

    return final_price
```

### 5.3 价差分析算法

```python
def analyze_spread(self, instrument_name, order_book):
    """
    分析价差

    Args:
        instrument_name: 标的名称
        order_book: 订单簿

    Returns:
        Dict: 价差分析结果
    """
    best_bid = order_book['bids'][0]['price'] if order_book['bids'] else 0
    best_ask = order_book['asks'][0]['price'] if order_book['asks'] else 0

    if best_bid == 0 or best_ask == 0:
        return {"status": "no_liquidity"}

    spread = best_ask - best_bid
    spread_ratio = spread / best_bid

    # 计算价差等级
    spread_level = self._determine_spread_level(spread_ratio)

    # 评估流动性
    liquidity_score = self._calculate_liquidity_score(order_book)

    # 预测滑点
    slippage_prediction = self._predict_slippage(spread_ratio, liquidity_score)

    return {
        "spread": spread,
        "spread_ratio": spread_ratio,
        "spread_level": spread_level,
        "liquidity_score": liquidity_score,
        "slippage_prediction": slippage_prediction,
        "best_bid": best_bid,
        "best_ask": best_ask
    }
```

## 6. 价格校正算法

### 6.1 分层定价校正

```python
def apply_tiered_pricing_correction(self, base_price, amount, instrument_type):
    """
    应用分层定价校正

    Args:
        base_price: 基础价格
        amount: 数量
        instrument_type: 标的类型

    Returns:
        float: 校正后价格
    """
    # 确定数量级别
    tiers = self.config["price_levels"][instrument_type]

    for tier_name, tier_config in sorted(tiers.items(), key=lambda x: x[1]["threshold"]):
        if amount <= tier_config["threshold"]:
            adjustment = tier_config["adjustment"]
            break
    else:
        # 使用最大级别
        adjustment = tiers["xlarge"]["adjustment"]

    # 应用价格调整
    if direction == "buy":
        corrected_price = base_price * (1 + adjustment)
    else:
        corrected_price = base_price * (1 - adjustment)

    return corrected_price
```

### 6.2 价差感知校正

```python
def apply_spread_aware_correction(self, base_price, spread_analysis, direction):
    """
    应用价差感知校正

    Args:
        base_price: 基础价格
        spread_analysis: 价差分析结果
        direction: 方向

    Returns:
        float: 校正后价格
    """
    spread_ratio = spread_analysis["spread_ratio"]
    spread_level = spread_analysis["spread_level"]

    # 根据价差等级选择校正系数
    correction_factors = {
        "tight": 0.0,
        "normal": 0.001,
        "wide": 0.003,
        "very_wide": 0.005
    }

    correction = correction_factors.get(spread_level, 0.0)

    # 应用校正
    if direction == "buy":
        corrected_price = base_price * (1 + correction)
    else:
        corrected_price = base_price * (1 - correction)

    return corrected_price
```

### 6.3 刻度大小计算

```python
def calculate_tick_size(self, price, instrument_type):
    """
    计算价格刻度大小

    Args:
        price: 价格
        instrument_type: 标的类型

    Returns:
        float: 刻度大小
    """
    base_tick = self.config["tick_sizes"][instrument_type]

    # 对于期权，根据价格动态调整刻度
    if instrument_type == "options":
        if price < 0.01:
            return 0.0001
        elif price < 0.1:
            return 0.0005
        elif price < 1.0:
            return 0.001
        else:
            return 0.005

    return base_tick
```

## 7. 缓存和性能优化

### 7.1 价格缓存

```python
class PriceCache:
    """价格缓存管理器"""

    def __init__(self, ttl_seconds=30):
        self.cache = {}
        self.ttl = ttl_seconds

    def get(self, instrument_name):
        """获取缓存价格"""
        if instrument_name in self.cache:
            entry = self.cache[instrument_name]
            if time.time() - entry["timestamp"] < self.ttl:
                return entry["price"]
        return None

    def set(self, instrument_name, price):
        """设置缓存价格"""
        self.cache[instrument_name] = {
            "price": price,
            "timestamp": time.time()
        }

    def clear_expired(self):
        """清除过期缓存"""
        current_time = time.time()
        expired_keys = [
            key for key, entry in self.cache.items()
            if current_time - entry["timestamp"] >= self.ttl
        ]
        for key in expired_keys:
            del self.cache[key]
```

### 7.2 并发控制

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncPriceCalculator:
    """异步价格计算器"""

    def __init__(self, max_concurrent_calculations=10):
        self.semaphore = asyncio.Semaphore(max_concurrent_calculations)
        self.executor = ThreadPoolExecutor(max_workers=5)

    async def calculate_price_async(self, instrument_name, amount, direction):
        """异步计算价格"""
        async with self.semaphore:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                self.executor,
                self._calculate_price_sync,
                instrument_name,
                amount,
                direction
            )
```

## 8. 监控和指标

### 8.1 关键指标

- 价格计算响应时间
- 价格缓存命中率
- 价差分析准确率
- 滑点预测准确率
- 定价成功率

### 8.2 性能监控

```python
import time
from functools import wraps

def monitor_price_calculation(func):
    """价格计算性能监控装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        result = await func(*args, **kwargs)
        end_time = time.time()

        # 记录性能指标
        duration = end_time - start_time
        self._record_performance_metric(func.__name__, duration)

        return result
    return wrapper
```

## 9. 错误处理

### 9.1 异常类型

```python
class SmartPricingError(Exception):
    """智能定价基础异常"""
    pass

class InvalidInstrumentError(SmartPricingError):
    """无效标的异常"""
    pass

class MarketDataError(SmartPricingError):
    """市场数据异常"""
    pass

class PricingTimeoutError(SmartPricingError):
    """定价超时异常"""
    pass

class UnsupportedOrderSizeError(SmartPricingError):
    """不支持订单大小异常"""
    pass
```

### 9.2 错误恢复策略

- 市场数据错误：使用缓存或默认值
- 定价超时：返回简化定价结果
- 无效标的：抛出异常并记录
- 网络问题：自动重试机制

## 10. 测试策略

### 10.1 单元测试

- 价格计算算法测试
- 价差分析测试
- 缓存机制测试
- 错误处理测试

### 10.2 集成测试

- 与Deribit API集成测试
- 市场数据服务集成测试
- 实时价格验证测试
- 异常市场条件测试

### 10.3 性能测试

- 高并发价格计算测试
- 缓存性能测试
- 响应时间测试
- 内存使用测试

## 11. 实施优先级

1. **Phase 1**: 基础价格计算和刻度管理
2. **Phase 2**: 价差分析和市场适应性
3. **Phase 3**: 期权专用定价功能
4. **Phase 4**: 性能优化和监控集成

## 12. 依赖关系

- Deribit Python客户端
- 市场数据服务
- 配置管理模块
- 缓存系统
- 监控系统
- 日志系统

## 13. 扩展性考虑

### 13.1 多交易所支持

- 支持不同交易所的定价规则
- 交易所特定价格校正
- 跨交易所套利定价

### 13.2 机器学习集成

- 基于历史数据优化定价算法
- 价格趋势预测
- 自适应定价策略

### 13.3 自定义定价策略

- 支持用户自定义定价规则
- 策略热加载
- A/B测试框架