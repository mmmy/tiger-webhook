# 手动轮询端点技术需求文档

## 1. 功能概述

手动轮询端点提供主动触发持仓、订单数据同步的能力，支持手动数据刷新、故障恢复和按需数据获取，确保系统数据的准确性和实时性。

## 2. 核心特性

### 2.1 手动轮询触发
- 手动持仓数据同步
- 手动订单数据同步
- 组合数据同步
- 按账户轮询

### 2.2 数据类型支持
- 持仓数据轮询
- 订单数据轮询
- 账户信息轮询
- 市场数据轮询

### 2.3 权限控制
- API密钥认证
- 账户权限验证
- 操作频率限制
- 操作审计日志

### 2.4 结果处理
- 实时结果返回
- 异步任务处理
- 结果缓存
- 错误处理

## 3. 技术架构

### 3.1 类结构设计

```python
class ManualPollingController:
    """手动轮询控制器"""

    def __init__(self, deribit_client, position_manager, order_manager, config):
        self.client = deribit_client
        self.position_manager = position_manager
        self.order_manager = order_manager
        self.config = config
        self.audit_logger = AuditLogger()

    async def poll_positions(self, account_id=None, force_refresh=False):
        """轮询持仓数据"""
        pass

    async def poll_orders(self, account_id=None, force_refresh=False):
        """轮询订单数据"""
        pass

    async def poll_positions_and_orders(self, account_id=None, force_refresh=False):
        """轮询持仓和订单数据"""
        pass

    async def get_polling_status(self, task_id=None):
        """获取轮询状态"""
        pass

    async def cancel_polling_task(self, task_id):
        """取消轮询任务"""
        pass
```

### 3.2 轮询任务管理器

```python
class PollingTaskManager:
    """轮询任务管理器"""

    def __init__(self, config):
        self.config = config
        self.active_tasks = {}
        self.task_history = {}
        self.task_counter = 0

    async def create_polling_task(self, task_type, parameters):
        """创建轮询任务"""
        pass

    async def monitor_task_progress(self, task_id):
        """监控任务进度"""
        pass

    async def complete_task(self, task_id, result):
        """完成任务"""
        pass

    async def fail_task(self, task_id, error):
        """任务失败"""
        pass

    def get_task_statistics(self):
        """获取任务统计"""
        pass
```

### 3.3 权限管理器

```python
class PollingAuthManager:
    """轮询权限管理器"""

    def __init__(self, config):
        self.config = config
        self.api_keys = {}
        self.rate_limiter = RateLimiter()

    async def authenticate_request(self, api_key, signature):
        """认证请求"""
        pass

    async def check_permissions(self, account_id, operation):
        """检查权限"""
        pass

    async def check_rate_limit(self, api_key):
        """检查频率限制"""
        pass

    async def log_operation(self, account_id, operation, result):
        """记录操作日志"""
        pass
```

### 3.4 结果处理器

```python
class PollingResultHandler:
    """轮询结果处理器"""

    def __init__(self, cache_manager, notification_service):
        self.cache = cache_manager
        self.notification = notification_service

    async def process_result(self, task_type, result):
        """处理轮询结果"""
        pass

    async def cache_result(self, cache_key, result):
        """缓存结果"""
        pass

    async def send_notifications(self, task_type, result, account_id):
        """发送通知"""
        pass

    async def generate_report(self, task_type, result):
        """生成报告"""
        pass
```

### 3.5 配置参数

```python
MANUAL_POLLING_CONFIG = {
    "enabled": True,
    "endpoints": {
        "poll_positions": {
            "enabled": True,
            "rate_limit": {
                "requests_per_minute": 10,
                "requests_per_hour": 100
            },
            "timeout": 30,  # 秒
            "cache_ttl": 60  # 秒
        },
        "poll_orders": {
            "enabled": True,
            "rate_limit": {
                "requests_per_minute": 15,
                "requests_per_hour": 150
            },
            "timeout": 30,
            "cache_ttl": 30
        },
        "poll_positions_and_orders": {
            "enabled": True,
            "rate_limit": {
                "requests_per_minute": 5,
                "requests_per_hour": 50
            },
            "timeout": 60,
            "cache_ttl": 60
        }
    },
    "task_management": {
        "max_concurrent_tasks": 5,
        "task_timeout": 300,  # 秒
        "retry_attempts": 3,
        "retry_delay": 5,  # 秒
        "result_retention": 3600  # 秒
    },
    "authentication": {
        "api_key_required": True,
        "signature_algorithm": "HMAC-SHA256",
        "token_expiry": 3600,  # 秒
        "ip_whitelist": []
    },
    "notifications": {
        "enabled": True,
        "on_success": False,
        "on_failure": True,
        "on_timeout": True,
        "channels": ["wechat", "email"]
    }
}
```

## 4. API接口设计

### 4.1 持仓轮询接口

```python
@app.post("/api/positions/poll")
async def poll_positions_endpoint(
    api_key: str = Header(...),
    signature: str = Header(...),
    account_id: str = Query(None),
    force_refresh: bool = Query(False),
    cache_key: str = Query(None)
) -> Dict:
    """
    手动轮询持仓数据

    Args:
        api_key: API密钥
        signature: 签名
        account_id: 账户ID(可选)
        force_refresh: 强制刷新
        cache_key: 缓存键(可选)

    Returns:
        Dict: 轮询结果
    """
    # 认证和权限检查
    auth_result = await polling_auth_manager.authenticate_request(api_key, signature)
    if not auth_result['success']:
        raise HTTPException(status_code=401, detail=auth_result['message'])

    # 检查频率限制
    rate_check = await polling_auth_manager.check_rate_limit(api_key)
    if not rate_check['allowed']:
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # 创建轮询任务
    task = await polling_task_manager.create_polling_task(
        task_type="positions",
        parameters={
            "account_id": account_id,
            "force_refresh": force_refresh,
            "cache_key": cache_key
        }
    )

    # 返回任务ID
    return {
        "success": True,
        "task_id": task['task_id'],
        "status": "started",
        "estimated_duration": task['estimated_duration']
    }
```

### 4.2 订单轮询接口

```python
@app.post("/api/orders/poll")
async def poll_orders_endpoint(
    api_key: str = Header(...),
    signature: str = Header(...),
    account_id: str = Query(None),
    force_refresh: bool = Query(False),
    include_history: bool = Query(False)
) -> Dict:
    """
    手动轮询订单数据

    Args:
        api_key: API密钥
        signature: 签名
        account_id: 账户ID(可选)
        force_refresh: 强制刷新
        include_history: 是否包含历史数据

    Returns:
        Dict: 轮询结果
    """
    # 认证和权限检查
    auth_result = await polling_auth_manager.authenticate_request(api_key, signature)
    if not auth_result['success']:
        raise HTTPException(status_code=401, detail=auth_result['message'])

    # 检查频率限制
    rate_check = await polling_auth_manager.check_rate_limit(api_key)
    if not rate_check['allowed']:
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # 创建轮询任务
    task = await polling_task_manager.create_polling_task(
        task_type="orders",
        parameters={
            "account_id": account_id,
            "force_refresh": force_refresh,
            "include_history": include_history
        }
    )

    return {
        "success": True,
        "task_id": task['task_id'],
        "status": "started",
        "estimated_duration": task['estimated_duration']
    }
```

### 4.3 组合轮询接口

```python
@app.post("/api/positions/poll-positions-and-orders")
async def poll_positions_and_orders_endpoint(
    api_key: str = Header(...),
    signature: str = Header(...),
    account_id: str = Query(None),
    force_refresh: bool = Query(False),
    include_order_history: bool = Query(False)
) -> Dict:
    """
    手动轮询持仓和订单数据

    Args:
        api_key: API密钥
        signature: 签名
        account_id: 账户ID(可选)
        force_refresh: 强制刷新
        include_order_history: 是否包含订单历史

    Returns:
        Dict: 轮询结果
    """
    # 认证和权限检查
    auth_result = await polling_auth_manager.authenticate_request(api_key, signature)
    if not auth_result['success']:
        raise HTTPException(status_code=401, detail=auth_result['message'])

    # 检查频率限制
    rate_check = await polling_auth_manager.check_rate_limit(api_key)
    if not rate_check['allowed']:
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # 创建轮询任务
    task = await polling_task_manager.create_polling_task(
        task_type="positions_and_orders",
        parameters={
            "account_id": account_id,
            "force_refresh": force_refresh,
            "include_order_history": include_order_history
        }
    )

    return {
        "success": True,
        "task_id": task['task_id'],
        "status": "started",
        "estimated_duration": task['estimated_duration']
    }
```

### 4.4 任务状态查询接口

```python
@app.get("/api/polling/status/{task_id}")
async def get_polling_status_endpoint(
    task_id: str,
    api_key: str = Header(...),
    signature: str = Header(...)
) -> Dict:
    """
    获取轮询任务状态

    Args:
        task_id: 任务ID
        api_key: API密钥
        signature: 签名

    Returns:
        Dict: 任务状态
    """
    # 认证检查
    auth_result = await polling_auth_manager.authenticate_request(api_key, signature)
    if not auth_result['success']:
        raise HTTPException(status_code=401, detail=auth_result['message'])

    # 获取任务状态
    status = await polling_task_manager.get_task_status(task_id)
    if not status:
        raise HTTPException(status_code=404, detail="Task not found")

    return status
```

### 4.5 任务取消接口

```python
@app.delete("/api/polling/tasks/{task_id}")
async def cancel_polling_task_endpoint(
    task_id: str,
    api_key: str = Header(...),
    signature: str = Header(...)
) -> Dict:
    """
    取消轮询任务

    Args:
        task_id: 任务ID
        api_key: API密钥
        signature: 签名

    Returns:
        Dict: 取消结果
    """
    # 认证检查
    auth_result = await polling_auth_manager.authenticate_request(api_key, signature)
    if not auth_result['success']:
        raise HTTPException(status_code=401, detail=auth_result['message'])

    # 取消任务
    result = await polling_task_manager.cancel_task(task_id)
    if not result['success']:
        raise HTTPException(status_code=404, detail=result['message'])

    return result
```

## 5. 业务逻辑流程

### 5.1 持仓轮询流程

1. **请求验证**
   - API密钥认证
   - 签名验证
   - 权限检查
   - 频率限制检查

2. **任务创建**
   - 生成任务ID
   - 设置任务参数
   - 启动异步任务
   - 记录任务信息

3. **数据获取**
   - 从Deribit API获取持仓数据
   - 处理分页数据
   - 验证数据完整性
   - 应用业务逻辑

4. **结果处理**
   - 更新本地数据库
   - 缓存结果
   - 发送通知
   - 记录操作日志

### 5.2 订单轮询算法

```python
async def poll_orders_data(self, account_id=None, force_refresh=False, include_history=False):
    """
    轮询订单数据

    Args:
        account_id: 账户ID
        force_refresh: 强制刷新
        include_history: 包含历史数据

    Returns:
        Dict: 订单数据
    """
    try:
        # 获取当前订单
        current_orders = await self.client.get_orders(
            currency=self.config['currency'],
            kind=self.config['kind']
        )

        # 获取历史订单（如果需要）
        historical_orders = []
        if include_history:
            historical_orders = await self.client.get_order_history(
                currency=self.config['currency'],
                count=100
            )

        # 合并订单数据
        all_orders = current_orders + historical_orders

        # 处理订单数据
        processed_orders = await self._process_orders_data(all_orders)

        # 更新本地数据库
        if force_refresh or not await self._check_orders_cache_validity():
            await self._update_orders_database(processed_orders)

        # 缓存结果
        await self._cache_orders_data(processed_orders)

        return {
            "success": True,
            "data": processed_orders,
            "timestamp": datetime.utcnow(),
            "counts": {
                "current": len(current_orders),
                "historical": len(historical_orders),
                "total": len(processed_orders)
            }
        }

    except Exception as e:
        logger.error(f"Error polling orders data: {e}")
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.utcnow()
        }
```

### 5.3 任务管理算法

```python
async def create_polling_task(self, task_type, parameters):
    """
    创建轮询任务

    Args:
        task_type: 任务类型
        parameters: 任务参数

    Returns:
        Dict: 任务信息
    """
    # 生成任务ID
    task_id = f"polling_{task_type}_{self.task_counter}"
    self.task_counter += 1

    # 创建任务信息
    task_info = {
        "task_id": task_id,
        "task_type": task_type,
        "parameters": parameters,
        "status": "created",
        "created_at": datetime.utcnow(),
        "estimated_duration": self._estimate_duration(task_type),
        "progress": 0.0,
        "result": None,
        "error": None
    }

    # 存储任务信息
    self.active_tasks[task_id] = task_info

    # 启动异步任务
    asyncio.create_task(self._execute_polling_task(task_id))

    return task_info

async def _execute_polling_task(self, task_id):
    """
    执行轮询任务

    Args:
        task_id: 任务ID
    """
    task = self.active_tasks.get(task_id)
    if not task:
        return

    try:
        # 更新任务状态
        task['status'] = 'running'
        task['started_at'] = datetime.utcnow()

        # 执行轮询
        if task['task_type'] == 'positions':
            result = await self.polling_controller.poll_positions(**task['parameters'])
        elif task['task_type'] == 'orders':
            result = await self.polling_controller.poll_orders(**task['parameters'])
        elif task['task_type'] == 'positions_and_orders':
            result = await self.polling_controller.poll_positions_and_orders(**task['parameters'])
        else:
            raise ValueError(f"Unknown task type: {task['task_type']}")

        # 更新任务状态
        task['status'] = 'completed'
        task['result'] = result
        task['completed_at'] = datetime.utcnow()
        task['progress'] = 1.0

        # 移动到历史记录
        self.task_history[task_id] = task.copy()
        del self.active_tasks[task_id]

    except Exception as e:
        # 处理任务失败
        task['status'] = 'failed'
        task['error'] = str(e)
        task['completed_at'] = datetime.utcnow()

        # 发送失败通知
        await self._send_failure_notification(task_id, e)

        # 移动到历史记录
        self.task_history[task_id] = task.copy()
        del self.active_tasks[task_id]
```

### 5.4 权限管理算法

```python
async def authenticate_request(self, api_key, signature):
    """
    认证请求

    Args:
        api_key: API密钥
        signature: 签名

    Returns:
        Dict: 认证结果
    """
    # 验证API密钥
    if api_key not in self.api_keys:
        return {
            "success": False,
            "message": "Invalid API key"
        }

    # 验证签名
    expected_signature = self._generate_signature(api_key)
    if not self._verify_signature(signature, expected_signature):
        return {
            "success": False,
            "message": "Invalid signature"
        }

    # 检查密钥是否过期
    key_info = self.api_keys[api_key]
        if datetime.utcnow() > key_info['expires_at']:
            return {
                "success": False,
                "message": "API key expired"
            }

    return {
        "success": True,
        "account_id": key_info['account_id'],
        "permissions": key_info['permissions']
    }

async def check_rate_limit(self, api_key):
    """
    检查频率限制

    Args:
        api_key: API密钥

    Returns:
        Dict: 频率限制结果
    """
    current_time = datetime.utcnow()
    key_info = self.api_keys[api_key]

    # 检查分钟限制
    minute_requests = [
        req for req in key_info['request_history']
        if current_time - req['timestamp'] < timedelta(minutes=1)
    ]

    if len(minute_requests) >= self.config['rate_limit']['requests_per_minute']:
        return {
            "allowed": False,
            "reason": "Minute rate limit exceeded",
            "reset_time": minute_requests[0]['timestamp'] + timedelta(minutes=1)
        }

    # 检查小时限制
    hour_requests = [
        req for req in key_info['request_history']
        if current_time - req['timestamp'] < timedelta(hours=1)
    ]

    if len(hour_requests) >= self.config['rate_limit']['requests_per_hour']:
        return {
            "allowed": False,
            "reason": "Hour rate limit exceeded",
            "reset_time": hour_requests[0]['timestamp'] + timedelta(hours=1)
        }

    # 记录请求
    key_info['request_history'].append({
        "timestamp": current_time,
        "endpoint": "polling"
    })

    return {
        "allowed": True,
        "remaining_minute": self.config['rate_limit']['requests_per_minute'] - len(minute_requests) - 1,
        "remaining_hour": self.config['rate_limit']['requests_per_hour'] - len(hour_requests) - 1
    }
```

## 6. 数据库设计

### 6.1 轮询任务表

```python
class PollingTask(BaseModel):
    """轮询任务"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    task_id: str
    task_type: str
    account_id: str
    status: str
    parameters: Dict
    created_at: datetime = Field(default_factory=datetime.utcnow)
    started_at: datetime = None
    completed_at: datetime = None
    result: Dict = None
    error: str = None
    duration: float = None
```

### 6.2 操作审计表

```python
class PollingAuditLog(BaseModel):
    """轮询操作审计日志"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    task_id: str
    account_id: str
    operation: str
    ip_address: str
    user_agent: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    result: str  # "success", "failed", "timeout"
    details: Dict = None
```

### 6.3 API密钥表

```python
class ApiKey(BaseModel):
    """API密钥"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    api_key: str
    account_id: str
    secret_hash: str
    permissions: List[str]
    created_at: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime
    last_used: datetime = None
    is_active: bool = True
```

## 7. 缓存机制

### 7.1 结果缓存

```python
class PollingCache:
    """轮询结果缓存"""

    def __init__(self, config):
        self.config = config
        self.cache = {}
        self.cleanup_interval = 300  # 5分钟清理一次

    async def get_cached_result(self, cache_key):
        """获取缓存结果"""
        if cache_key in self.cache:
            entry = self.cache[cache_key]
            if datetime.utcnow() - entry['timestamp'] < timedelta(seconds=entry['ttl']):
                return entry['data']
            else:
                del self.cache[cache_key]
        return None

    async def set_cached_result(self, cache_key, data, ttl=None):
        """设置缓存结果"""
        if ttl is None:
            ttl = self.config['cache_ttl']

        self.cache[cache_key] = {
            "data": data,
            "timestamp": datetime.utcnow(),
            "ttl": ttl
        }

    async def cleanup_expired_cache(self):
        """清理过期缓存"""
        current_time = datetime.utcnow()
        expired_keys = [
            key for key, entry in self.cache.items()
            if current_time - entry['timestamp'] > timedelta(seconds=entry['ttl'])
        ]
        for key in expired_keys:
            del self.cache[key]
```

### 7.2 缓存键生成

```python
def generate_cache_key(self, task_type, parameters):
    """
    生成缓存键

    Args:
        task_type: 任务类型
        parameters: 参数

    Returns:
        str: 缓存键
    """
    # 创建参数字典的规范表示
    normalized_params = {
        k: v for k, v in parameters.items()
        if v is not None and k != 'force_refresh'
    }

    # 生成键字符串
    params_str = json.dumps(normalized_params, sort_keys=True)
    cache_key = f"polling_{task_type}_{hashlib.md5(params_str.encode()).hexdigest()}"

    return cache_key
```

## 8. 错误处理

### 8.1 异常类型

```python
class PollingError(Exception):
    """轮询基础异常"""
    pass

class AuthenticationError(PollingError):
    """认证异常"""
    pass

class RateLimitError(PollingError):
    """频率限制异常"""
    pass

class TaskTimeoutError(PollingError):
    """任务超时异常"""
    pass

class DataProcessingError(PollingError):
    """数据处理异常"""
    pass
```

### 8.2 错误恢复策略

- API认证失败：返回401错误
- 频率限制：返回429错误和重试时间
- 网络超时：重试或返回缓存数据
- 数据处理错误：记录错误并返回部分结果

## 9. 监控和指标

### 9.1 关键指标

- 轮询成功率
- 平均响应时间
- 任务队列长度
- 缓存命中率
- API调用频率

### 9.2 性能监控

```python
class PollingMetrics:
    """轮询指标收集器"""

    def __init__(self):
        self.metrics = {
            "requests_total": 0,
            "requests_success": 0,
            "requests_failed": 0,
            "avg_response_time": 0.0,
            "cache_hits": 0,
            "cache_misses": 0,
            "active_tasks": 0,
            "task_completions": 0,
            "task_failures": 0
        }

    def record_request(self, success, response_time):
        """记录请求"""
        self.metrics["requests_total"] += 1
        if success:
            self.metrics["requests_success"] += 1
        else:
            self.metrics["requests_failed"] += 1

        # 更新平均响应时间
        total = self.metrics["requests_total"]
        self.metrics["avg_response_time"] = (
            (self.metrics["avg_response_time"] * (total - 1) + response_time) / total
        )

    def record_cache_hit(self):
        """记录缓存命中"""
        self.metrics["cache_hits"] += 1

    def record_cache_miss(self):
        """记录缓存未命中"""
        self.metrics["cache_misses"] += 1

    def get_cache_hit_rate(self):
        """获取缓存命中率"""
        total = self.metrics["cache_hits"] + self.metrics["cache_misses"]
        if total == 0:
            return 0.0
        return self.metrics["cache_hits"] / total
```

## 10. 测试策略

### 10.1 单元测试

- 认证机制测试
- 频率限制测试
- 任务管理测试
- 缓存机制测试

### 10.2 集成测试

- API端点集成测试
- 数据库集成测试
- 通知服务集成测试
- 完整流程测试

### 10.3 性能测试

- 高并发请求测试
- 大量任务处理测试
- 缓存性能测试
- 内存使用测试

## 11. 实施优先级

1. **Phase 1**: 基础轮询端点和权限管理
2. **Phase 2**: 任务管理和结果处理
3. **Phase 3**: 缓存机制和性能优化
4. **Phase 4**: 监控系统和高级特性

## 12. 依赖关系

- FastAPI框架
- Deribit Python客户端
- 数据库访问层
- 缓存系统
- 通知服务
- 监控系统

## 13. 扩展性考虑

### 13.1 多数据源支持

- 支持多个交易所数据源
- 支持本地数据库轮询
- 支持第三方数据源

### 13.2 高级调度

- 支持定时任务
- 支持任务依赖关系
- 支持任务优先级调度

### 13.3 分析和报告

- 轮询数据分析
- 性能报告生成
- 异常检测和预警